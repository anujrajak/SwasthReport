{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 112, "column": 0}, "map": {"version":3,"sources":["file:///Users/anujrajak/Learn/Pathology/patho-client/lib/db/mongodb.ts"],"sourcesContent":["import { MongoClient, MongoClientOptions } from \"mongodb\";\n\nif (!process.env.MONGODB_URI) {\n  throw new Error(\n    \"Please define the MONGODB_URI environment variable inside .env.local\"\n  );\n}\n\nconst uri = process.env.MONGODB_URI;\n\n// Configure MongoDB connection options\nconst options: MongoClientOptions = {\n  // MongoDB Atlas requires TLS/SSL\n  // The driver automatically handles TLS for mongodb+srv:// connections\n  // Connection pool settings\n  maxPoolSize: 10,\n  minPoolSize: 1,\n  // Timeout settings\n  connectTimeoutMS: 30000,\n  serverSelectionTimeoutMS: 30000,\n  // Retry settings\n  retryWrites: true,\n  retryReads: true,\n};\n\nlet client: MongoClient;\nlet clientPromise: Promise<MongoClient>;\n\nif (process.env.NODE_ENV === \"development\") {\n  // In development mode, use a global variable so that the value\n  // is preserved across module reloads caused by HMR (Hot Module Replacement).\n  const globalWithMongo = global as typeof globalThis & {\n    _mongoClientPromise?: Promise<MongoClient>;\n  };\n\n  if (!globalWithMongo._mongoClientPromise) {\n    client = new MongoClient(uri, options);\n    globalWithMongo._mongoClientPromise = client.connect();\n  }\n  clientPromise = globalWithMongo._mongoClientPromise;\n} else {\n  // In production mode, it's best to not use a global variable.\n  client = new MongoClient(uri, options);\n  clientPromise = client.connect();\n}\n\n// Export a module-scoped MongoClient promise. By doing this in a\n// separate module, the client can be shared across functions.\nexport default clientPromise;\n"],"names":[],"mappings":";;;;AAAA;;AAEA,IAAI,CAAC,QAAQ,GAAG,CAAC,WAAW,EAAE;IAC5B,MAAM,IAAI,MACR;AAEJ;AAEA,MAAM,MAAM,QAAQ,GAAG,CAAC,WAAW;AAEnC,uCAAuC;AACvC,MAAM,UAA8B;IAClC,iCAAiC;IACjC,sEAAsE;IACtE,2BAA2B;IAC3B,aAAa;IACb,aAAa;IACb,mBAAmB;IACnB,kBAAkB;IAClB,0BAA0B;IAC1B,iBAAiB;IACjB,aAAa;IACb,YAAY;AACd;AAEA,IAAI;AACJ,IAAI;AAEJ,wCAA4C;IAC1C,+DAA+D;IAC/D,6EAA6E;IAC7E,MAAM;IAIN,IAAI,CAAC,gBAAgB,mBAAmB,EAAE;QACxC,SAAS,IAAI,sHAAW,CAAC,KAAK;QAC9B,gBAAgB,mBAAmB,GAAG,OAAO,OAAO;IACtD;IACA,gBAAgB,gBAAgB,mBAAmB;AACrD;;uCAQe"}},
    {"offset": {"line": 154, "column": 0}, "map": {"version":3,"sources":["file:///Users/anujrajak/Learn/Pathology/patho-client/lib/db/models/user.ts"],"sourcesContent":["import clientPromise from \"../mongodb\";\nimport { ObjectId } from \"mongodb\";\n\nexport interface User {\n  _id?: ObjectId;\n  name: string;\n  email: string;\n  image?: string;\n  emailVerified?: boolean;\n  googleId?: string;\n  createdAt: Date;\n  updatedAt: Date;\n  lastLoginAt?: Date;\n}\n\nexport interface CreateUserInput {\n  name: string;\n  email: string;\n  image?: string;\n  emailVerified?: boolean;\n  googleId?: string;\n}\n\n/**\n * Find user by email\n */\nexport async function findUserByEmail(email: string): Promise<User | null> {\n  const client = await clientPromise;\n  const db = client.db();\n  const user = await db.collection<User>(\"users\").findOne({ email });\n  return user;\n}\n\n/**\n * Find user by Google ID\n */\nexport async function findUserByGoogleId(\n  googleId: string\n): Promise<User | null> {\n  const client = await clientPromise;\n  const db = client.db();\n  const user = await db.collection<User>(\"users\").findOne({ googleId });\n  return user;\n}\n\n// Track if indexes have been initialized\nlet indexesInitialized = false;\n\n/**\n * Ensure indexes are created (called automatically on first use)\n */\nasync function ensureIndexes() {\n  if (indexesInitialized) return;\n\n  try {\n    const client = await clientPromise;\n    const db = client.db();\n    const collection = db.collection<User>(\"users\");\n\n    // Create indexes if they don't exist (idempotent)\n    await collection.createIndex({ email: 1 }, { unique: true });\n    await collection.createIndex(\n      { googleId: 1 },\n      { unique: true, sparse: true }\n    );\n    await collection.createIndex({ createdAt: 1 });\n\n    indexesInitialized = true;\n  } catch (error) {\n    // If indexes already exist, that's fine\n    const mongoError = error as { code?: number };\n    if (mongoError.code !== 85) {\n      // Error code 85 = IndexOptionsConflict (index already exists)\n      console.warn(\"Index creation warning:\", error);\n    }\n    indexesInitialized = true; // Mark as initialized to avoid retrying\n  }\n}\n\n/**\n * Create a new user\n */\nexport async function createUser(input: CreateUserInput): Promise<User> {\n  // Ensure indexes exist before creating user\n  await ensureIndexes();\n\n  const client = await clientPromise;\n  const db = client.db();\n  const now = new Date();\n\n  const newUser: Omit<User, \"_id\"> = {\n    name: input.name,\n    email: input.email,\n    image: input.image,\n    emailVerified: input.emailVerified ?? false,\n    googleId: input.googleId,\n    createdAt: now,\n    updatedAt: now,\n    lastLoginAt: now,\n  };\n\n  const result = await db.collection<User>(\"users\").insertOne(newUser as User);\n\n  const user = await db.collection<User>(\"users\").findOne({\n    _id: result.insertedId,\n  });\n\n  if (!user) {\n    throw new Error(\"Failed to create user\");\n  }\n\n  return user;\n}\n\n/**\n * Update user information\n */\nexport async function updateUser(\n  userId: ObjectId,\n  updates: Partial<CreateUserInput>\n): Promise<User> {\n  const client = await clientPromise;\n  const db = client.db();\n\n  const updateResult = await db.collection<User>(\"users\").findOneAndUpdate(\n    { _id: userId },\n    {\n      $set: {\n        ...updates,\n        updatedAt: new Date(),\n        lastLoginAt: new Date(),\n      },\n    },\n    { returnDocument: \"after\" }\n  );\n\n  if (!updateResult) {\n    throw new Error(\"Failed to update user\");\n  }\n\n  return updateResult;\n}\n\n/**\n * Find or create user (upsert)\n */\nexport async function findOrCreateUser(input: CreateUserInput): Promise<User> {\n  // Try to find by Google ID first\n  if (input.googleId) {\n    console.log(\"------------->\", { input });\n    const existingUser = await findUserByGoogleId(input.googleId);\n    if (existingUser) {\n      // Update user info and last login\n      return updateUser(existingUser._id!, {\n        name: input.name,\n        email: input.email,\n        image: input.image,\n        emailVerified: input.emailVerified,\n      });\n    }\n  }\n\n  // Try to find by email\n  const existingUser = await findUserByEmail(input.email);\n  if (existingUser) {\n    // Update user info and last login\n    return updateUser(existingUser._id!, {\n      name: input.name,\n      email: input.email,\n      image: input.image,\n      emailVerified: input.emailVerified,\n      googleId: input.googleId,\n    });\n  }\n\n  console.log(\"--------------------->\");\n  // Create new user\n  return createUser(input);\n}\n\n/**\n * Initialize database indexes (optional - indexes are auto-created on first use)\n * You can call this manually if you want to create indexes upfront\n */\nexport async function initializeUserIndexes(): Promise<void> {\n  await ensureIndexes();\n}\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 306, "column": 0}, "map": {"version":3,"sources":["file:///Users/anujrajak/Learn/Pathology/patho-client/app/api/auth/%5B...nextauth%5D/route.ts"],"sourcesContent":["import NextAuth from \"next-auth\";\nimport GoogleProvider from \"next-auth/providers/google\";\nimport { findOrCreateUser } from \"@/lib/db/models/user\";\n\nexport const authOptions = {\n  // Using JWT sessions (no database adapter needed for NextAuth v4)\n  session: {\n    strategy: \"jwt\",\n  },\n  providers: [\n    GoogleProvider({\n      clientId: process.env.AUTH_GOOGLE_ID || process.env.GOOGLE_CLIENT_ID,\n      clientSecret:\n        process.env.AUTH_GOOGLE_SECRET || process.env.GOOGLE_CLIENT_SECRET,\n    }),\n  ],\n  secret: process.env.AUTH_SECRET || process.env.NEXTAUTH_SECRET,\n  pages: {\n    signIn: \"/\",\n  },\n  callbacks: {\n    async signIn({ user, account, profile }) {\n      // Save/update user in our custom users collection\n      if (account?.provider === \"google\" && user.email && user.name) {\n        try {\n          await findOrCreateUser({\n            name: user.name,\n            email: user.email,\n            image: user.image || undefined,\n            emailVerified: profile?.email_verified || false,\n            googleId: account.providerAccountId,\n          });\n        } catch (error) {\n          console.error(\"Error saving user to database:\", error);\n          // Don't block sign in if user save fails\n        }\n      }\n      return true;\n    },\n    async redirect({ url, baseUrl }) {\n      // Allows relative callback URLs\n      if (url.startsWith(\"/\")) return `${baseUrl}${url}`;\n      // Allows callback URLs on the same origin\n      if (new URL(url).origin === baseUrl) return url;\n      return baseUrl;\n    },\n  },\n};\n\nconst handler = NextAuth(authOptions);\nexport { handler as GET, handler as POST };\n"],"names":[],"mappings":";;;;;;;;AAAA;AACA;AACA;;;;AAEO,MAAM,cAAc;IACzB,kEAAkE;IAClE,SAAS;QACP,UAAU;IACZ;IACA,WAAW;QACT,IAAA,8ZAAc,EAAC;YACb,UAAU,QAAQ,GAAG,CAAC,cAAc,IAAI,QAAQ,GAAG,CAAC,gBAAgB;YACpE,cACE,QAAQ,GAAG,CAAC,kBAAkB,IAAI,QAAQ,GAAG,CAAC,oBAAoB;QACtE;KACD;IACD,QAAQ,QAAQ,GAAG,CAAC,WAAW,IAAI,QAAQ,GAAG,CAAC,eAAe;IAC9D,OAAO;QACL,QAAQ;IACV;IACA,WAAW;QACT,MAAM,QAAO,EAAE,IAAI,EAAE,OAAO,EAAE,OAAO,EAAE;YACrC,kDAAkD;YAClD,IAAI,SAAS,aAAa,YAAY,KAAK,KAAK,IAAI,KAAK,IAAI,EAAE;gBAC7D,IAAI;oBACF,MAAM,IAAA,iLAAgB,EAAC;wBACrB,MAAM,KAAK,IAAI;wBACf,OAAO,KAAK,KAAK;wBACjB,OAAO,KAAK,KAAK,IAAI;wBACrB,eAAe,SAAS,kBAAkB;wBAC1C,UAAU,QAAQ,iBAAiB;oBACrC;gBACF,EAAE,OAAO,OAAO;oBACd,QAAQ,KAAK,CAAC,kCAAkC;gBAChD,yCAAyC;gBAC3C;YACF;YACA,OAAO;QACT;QACA,MAAM,UAAS,EAAE,GAAG,EAAE,OAAO,EAAE;YAC7B,gCAAgC;YAChC,IAAI,IAAI,UAAU,CAAC,MAAM,OAAO,GAAG,UAAU,KAAK;YAClD,0CAA0C;YAC1C,IAAI,IAAI,IAAI,KAAK,MAAM,KAAK,SAAS,OAAO;YAC5C,OAAO;QACT;IACF;AACF;AAEA,MAAM,UAAU,IAAA,gZAAQ,EAAC"}}]
}